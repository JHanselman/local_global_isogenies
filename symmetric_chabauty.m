////// Relative Symmetric Chabauty /////
////// In the functions below we have implemented the relative symmetric Chabauty and the Mordell-Weil sieve for the curve XD10 //////



//// Relative Symmetric Chabauty ////

intrinsic AnnihilatorSpaceOfDifferentialsModp(Xp::Crv) -> SeqEnum
{
	Xp: a curve over a finite field

	Output: A sequence of diffentials that are the annihilator of JXp(Fp) 
}
  Rp := CoordinateRing(AmbientSpace(Xp));
  w11p := iso<Xp -> Xp | [-Rp.1, -Rp.2, -Rp.3, Rp.4, Rp.5, -Rp.6], [-Rp.1, -Rp.2, -Rp.3, Rp.4, Rp.5, -Rp.6]>;
  
	Vom, VomToOmega := SpaceOfDifferentialsFirstKind(Xp);
	vanishing_differentials_modp := hom<Vom -> Vom | [(Pullback(w11p, VomToOmega (Vom.i)))@@VomToOmega - Vom.i : i in [1..Genus(Xp)]]>;
	vanishing_differentials_modp := Image(vanishing_differentials_modp);
	vanishing_differentials_modp := [VomToOmega(omega) : omega in Basis(vanishing_differentials_modp)];
	
	return vanishing_differentials_modp;
end intrinsic;


intrinsic SinglePointOnResidueClass(divisor::DivCrvElt, p::RngIntElt) -> BoolElt
{
	divisor: a degree 2 divisor over Q
	p: a rational prime;

	Output: True if Pt is the only point in the residue class of the Symmetric Power modulo p, else False
}
	assert Degree(divisor) le 2;
	
  QQ := RationalsAsNumberField();
	X := Curve(Parent(divisor));
	Q1 := Decomposition(divisor)[1][1];
	K := ResidueClassField(Q1);
	L := QuadraticField(SquareFree(Discriminant(K)));
	iso, KtoL := IsIsomorphic(K, L);
  assert iso;
  
	Q1 := [KtoL(ai) : ai in Eltseq(RepresentativePoint(Q1))];

	OL := RingOfIntegers(L);
	pr := Factorization(p*OL)[1][1];
	uni_pr := UniformizingElement(pr);
	fpr := InertiaDegree(pr);
	Fp, OLtoFp := ResidueClassField(pr);
	Xp := ChangeRing(X, Fp);
  
	V := AnnihilatorSpaceOfDifferentialsModp(Xp);

	min_val := Minimum([Valuation(ai, pr) : ai in Q1 | not IsZero(ai)]);
	Q1red := [uni_pr^(-min_val)*ai : ai in Q1];
	Q1p := Xp![OLtoFp(ai) : ai in Q1red];
	tQ1p := UniformizingParameter(Q1p);
  for omega in V do
    a0 := (omega/Differential(tQ1p))(Q1p);
    if a0 ne 0 then
      return true;
    end if;
  end for;
	
	return false;
end intrinsic;


intrinsic PointsLieOnSingleResidueClass(X::Crv, sym_pts::SeqEnum, primes::SeqEnum) -> SeqEnum
{
	X: the curve XD10 over QQ
	sym_pts: a sequence of rational degree 2 divisors that represent points on X^(2)(Q)
	primes: a sequence of primes over we will apply the relative symmetric Chabauty method.

	Output: A sequence of pairs [p, bol], when p lies in primes and bol is True if every point in S lies in a single residue class modulo p. 
}
	chabauty_primes := [];
	for p in primes do
		bol := true;
		for sym_pt in sym_pts do
			if not SinglePointOnResidueClass(sym_pt, p) then
				bol := false;
				break;
			end if;
		end for;
    if bol then
		  Append(~chabauty_primes, p);
    end if;
	end for;

	return chabauty_primes;	
end intrinsic;




//// Mordell-Weil Sieve ////

intrinsic DegreeTwoDivisorsOfXp(Xp::Crv) -> SeqEnum
{
	Xp: the reduction of X mod p

	Output: The degree 2 divisors of Xp.
}
	p := Characteristic(BaseRing(Xp));
	pts := [Divisor(Place(pt)) : pt in Points(Xp,GF(p^2)) | not IsSingular(pt)];
	divs_deg1 := [pt : pt in pts | Degree(pt) eq 1];
	divs_deg2 := [pt : pt in pts | Degree(pt) eq 2];
	
	Xp_sym2 := [pt1 + pt2 : pt1, pt2 in divs_deg1];
	for pt in divs_deg2 do
		if pt notin Xp_sym2 then
			Append(~Xp_sym2, pt);
		end if;
	end for;
	return Xp_sym2;
end intrinsic;


intrinsic ReduceDivisorModp(D::DivCrvElt, Xp::Crv) -> DivCrvElt
{
	D: a divisor of X
	Xp: the reduction of X mod p
	
	Output: The divisor of D mod p.
}
	X := Curve(Parent(D));
	p := Characteristic(BaseRing(Xp));
	I := Ideal(D);
	poly_gens := Basis(I) cat DefiningPolynomials(X);	

	assert Rank(CoordinateRing(Xp)) eq Rank(CoordinateRing(X));
	Zx := PolynomialRing(Integers(), Rank(CoordinateRing(Xp)));
	
	poly_gens_reduced := [];
	for f in poly_gens do
		fred := f * LCM([Denominator(c) : c in Coefficients(f)]);
		vp := Minimum([Valuation(c, p) : c in Coefficients(fred)]);
		fred := fred * p^(-vp);
		Append(~poly_gens_reduced, fred);
	end for;

	Ired := ideal<Zx | poly_gens_reduced>;
	Fpx := CoordinateRing(AmbientSpace(Xp));
	poly_gens_modp := [Evaluate(f, [Fpx.i : i in [1..Rank(Fpx)]]) : f in poly_gens_reduced];
	Imodp := ideal<Fpx | poly_gens_modp>;
	Dp := Divisor(Xp, Imodp);
	
	return Dp;
end intrinsic;


intrinsic MordellWeilSieveSinglePrimeInfo(X::Crv, Gens::SeqEnum, G::GrpAb, sym_pts::SeqEnum, p::RngIntElt, N::RngIntElt) -> SeqEnum, GrpAb
{
	X: a curve over QQ
	Gens: a sequence of divisors [P1, P2, ..., Pn] such that [P1 - Pinf, P2 - Pinf, ..., Pn - Pinf] generate a subgroup of J(Q) of finite index.
	G: the finite index subgroup of J(Q) as an abstract abelian group.
	sym_pts: a sequence of rational degree 2 divisors that represent points on X^(2)(Q). The last divisor is the point at infinity.
	p: a prime number
	N: a positive integer such that N*J(Q) lies in the subgroup generated by Gens

	Output: Representatives of the cosets that correspond to preimages of Mp under phi_p and the kernel of phi_p map.
}
	Pinf := sym_pts[#sym_pts];	
	Fp := GF(p);
	Xp := ChangeRing(X, Fp);
	ClXp, ClXpToDivXp, DivXpToClXp := ClassGroup(Xp);
	Z := AbelianGroup([0]);
	deg_map := hom<ClXp -> Z | [Degree(ClXpToDivXp(a)) : a in OrderedGenerators(ClXp)]>;
	JFp := Kernel(deg_map);
	sym_pts_modp := [ReduceDivisorModp(D, Xp) : D in sym_pts];
	Gens_modp := [ReduceDivisorModp(D, Xp) : D in Gens];
	Pinf_modp := sym_pts_modp[#sym_pts_modp];
	phi_p := hom<G -> JFp | [JFp!(DivXpToClXp(D) - DivXpToClXp(Pinf_modp)) : D in Gens_modp]>;
	Gmodp := Image(phi_p);

	// Determination of the set Mp
	Xp_sym2 := DegreeTwoDivisorsOfXp(Xp);
	im_ip := [N * JFp!(DivXpToClXp(D) - DivXpToClXp(Pinf_modp)) : D in Xp_sym2];

	Mp := [];	
	for pt in Xp_sym2 do
		if pt notin sym_pts_modp then
			Append(~Mp, pt);
		end if;
	end for;
	ip_Mp := [N * JFp!(DivXpToClXp(D) - DivXpToClXp(Pinf_modp)) : D in Mp];
	Mp_cosets := [pt@@phi_p : pt in ip_Mp | pt in Image(phi_p)];
	ker_phip := Kernel(phi_p);
		
	return Mp_cosets, ker_phip;
end intrinsic;


intrinsic MordellWeilSieve(X::Crv, Gens::SeqEnum, Gens_order::SeqEnum, sym_pts::SeqEnum, primes::SeqEnum, N::RngIntElt) -> BoolElt
{
	X: a curve over QQ
	Gens: a sequence of divisors [P1, P2, ..., Pn] such that [P1 - Pinf, P2 - Pinf, ..., Pn - Pinf] generate a subgroup of J(Q) of finite index.
	Gens_order: the order of each point of Gens
	sym_pts: a sequence of rational degree 2 divisors that represent points on X^(2)(Q). The last divisor is the point at infinity.
	primes: a sequence of primes over the relative symmetric Chabauty works for the set of points in sym_pts
	N: a positive integer such that N*J(Q) lies in the subgroup generated by Gens

	Output: True if we can apply the Mordell-Weil sieve for the set of quadratic points sym_pts and the given primes
}

	G := AbelianGroup(Gens_order);
	W, H := MordellWeilSieveSinglePrimeInfo(X, Gens, G, sym_pts, primes[1], N);
	if #W eq 0 then
		return true;
	end if;
	_, HtoG := sub<G | H>;
	
	for i in [2..#primes] do
		p := primes[i];
		printf "p: %o\n", p;
		Wp, Hp := MordellWeilSieveSinglePrimeInfo(X, Gens, G, sym_pts, p, N);
		_, HpToG := sub<G | Hp>;
		Hnew := H meet Hp;
		quoHnew, GToquoHnew := quo<G | Hnew>;
		quoH := GToquoHnew(H);
		quoHp := GToquoHnew(Hp);
		cosetsW := {a + b : a in Set(quoH), b in [GToquoHnew(c) : c in W]};
		cosetsWp := {a + b : a in Set(quoHp), b in [GToquoHnew(c) : c in Wp]};
		W := [pt@@GToquoHnew : pt in cosetsW meet cosetsWp];
		H := Hnew;
		printf "W: %o\n", #W;
		printf "quoHnew: %o\n", quoHnew;
		if #W eq 0 then
			return true;
		end if;
	end for;

	return false;
end intrinsic;


